<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Bluesky Thread Viewer</title>
  <style>
    :root {
      --depth-color-1: hsl(200, 70%, 50%);
      --depth-color-2: hsl(30, 80%, 50%);
      --depth-color-3: hsl(120, 60%, 40%);
      --depth-color-4: hsl(0, 70%, 50%);
      --depth-color-5: hsl(280, 60%, 50%);
      --depth-color-6: hsl(20, 60%, 40%);
      --depth-color-7: hsl(330, 60%, 50%);
      --depth-color-8: hsl(0, 0%, 40%);
    }
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 1em;
    }
    .main-layout {
      display: flex;
      gap: 1em;
    }
    .content-area {
      flex: 1;
      min-width: 0;
      max-width: 800px;
    }
    .ai-panel {
      width: 400px;
      flex-shrink: 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 1em;
      background: #f9f9f9;
      position: sticky;
      top: 1em;
      max-height: calc(100vh - 2em);
      overflow-y: auto;
      display: none;
    }
    .ai-panel.visible {
      display: block;
    }
    .ai-panel h3 {
      margin-top: 0;
      margin-bottom: 0.5em;
      color: #333;
    }
    .ai-controls {
      display: flex;
      gap: 0.5em;
      margin-bottom: 1em;
      flex-wrap: wrap;
    }
    .ai-controls select,
    .ai-controls input[type="password"] {
      padding: 0.5em;
      font-size: 0.9rem;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .ai-controls select {
      width: 120px;
    }
    .ai-controls input[type="password"] {
      flex: 1;
      min-width: 150px;
    }
    .ai-response {
      white-space: pre-wrap;
      line-height: 1.5;
      font-size: 0.95rem;
    }
    .ai-response.loading {
      color: #666;
      font-style: italic;
    }
    .ai-response.error {
      color: #c00;
    }
    .ai-selected-post {
      background: #e3f2fd;
      border: 1px solid #90caf9;
      border-radius: 4px;
      padding: 0.5em;
      margin-bottom: 1em;
      font-size: 0.85rem;
    }
    .ai-selected-post .selected-author {
      font-weight: bold;
      margin-bottom: 0.25em;
    }
    .ai-selected-post .selected-text {
      color: #333;
    }
    header {
       max-width: 800px;
    }
    .controls {
      margin-bottom: 1em;
    }
    form {
      display: flex;
      gap: 0.5em;
    }
    input[type="text"] {
      flex: 1;
      font-size: 1rem;
      padding: 0.5em;
    }
    #urlForm button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 0.5em 1em;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
    }
    .copy-container {
      display: none;
      margin-bottom: 1em;
    }
    #copyBtn,
    #copyJsonBtn {
      background-color: #28a745;
      color: white;
      border: none;
      padding: 0.5em 1em;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      margin-right: 0.5em;
    }
    .tabs {
      display: none;
      margin-bottom: 1em;
      border-bottom: 2px solid #ddd;
    }
    .tab {
      background: none;
      border: none;
      padding: 0.75em 1.5em;
      font-size: 1rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      margin-bottom: -2px;
      color: #666;
    }
    .tab:hover {
      color: #333;
    }
    .tab.active {
      color: #007bff;
      border-bottom-color: #007bff;
      font-weight: bold;
    }
    .reply-to {
      font-size: 0.8rem;
      color: #888;
      margin-bottom: 0.25em;
    }
    .reply-to a {
      color: #007bff;
      text-decoration: none;
    }
    .reply-to a:hover {
      text-decoration: underline;
    }
    .post.highlighted {
      background-color: #fffde7;
      transition: background-color 0.3s;
    }
    .post {
      position: relative;
      border: 1px solid #ccc;
      padding: 0.75em 2px 0.75em 0.75em;
      border-radius: 6px;
      margin-top: 1em;
    }
    .post::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 4px;
      background-color: var(--stripe-color, transparent);
      border-top-left-radius: 6px;
      border-bottom-left-radius: 6px;
    }
    .depth-1 { --stripe-color: var(--depth-color-1); }
    /* Connect consecutive root-level posts by the thread author */
    .post.depth-1.author-continuation {
      margin-top: 0;
      border-top: none;
      border-top-left-radius: 0;
      border-top-right-radius: 0;
    }
    .post.depth-1.author-continuation::before {
      border-top-left-radius: 0;
    }
    .post.depth-1:has(+ .post.depth-1.author-continuation) {
      border-bottom: none;
      border-bottom-left-radius: 0;
      border-bottom-right-radius: 0;
    }
    .post.depth-1:has(+ .post.depth-1.author-continuation)::before {
      border-bottom-left-radius: 0;
    }
    .depth-2 { --stripe-color: var(--depth-color-2); }
    .depth-3 { --stripe-color: var(--depth-color-3); }
    .depth-4 { --stripe-color: var(--depth-color-4); }
    .depth-5 { --stripe-color: var(--depth-color-5); }
    .depth-6 { --stripe-color: var(--depth-color-6); }
    .depth-7 { --stripe-color: var(--depth-color-7); }
    .depth-8 { --stripe-color: var(--depth-color-8); }
    .author {
      font-weight: bold;
      margin-bottom: 0.25em;
    }
    .meta {
      color: #666;
      font-size: 0.85rem;
      margin-bottom: 0.5em;
      display: flex;
      gap: 0.5em;
      align-items: center;
    }
    .meta a {
      font-size: 0.85rem;
      color: #007bff;
      text-decoration: none;
    }
    .text {
      white-space: pre-wrap;
      font-size: 1rem;
      line-height: 1.4;
    }
    .images {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5em;
      margin-top: 0.5em;
    }
    .images img {
      max-height: 150px;
      border-radius: 8px;
      cursor: pointer;
      object-fit: cover;
    }
    .images img:hover {
      opacity: 0.9;
    }
    #imageModal {
      border: none;
      background: transparent;
      max-width: 100vw;
      max-height: 100vh;
      padding: 0;
    }
    #imageModal::backdrop {
      background: rgba(0, 0, 0, 0.9);
    }
    #imageModal img {
      max-width: 95vw;
      max-height: 95vh;
      object-fit: contain;
    }
    #imageModal:focus {
      outline: none;
    }
    /* Video thumbnail styling */
    .video-container {
      position: relative;
      display: inline-block;
      margin-top: 0.5em;
      cursor: pointer;
    }
    .video-container img {
      max-height: 200px;
      border-radius: 8px;
      object-fit: cover;
    }
    .video-container:hover img {
      opacity: 0.9;
    }
    .video-play-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      background: rgba(0, 0, 0, 0.7);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }
    .video-play-icon::after {
      content: '';
      width: 0;
      height: 0;
      border-left: 20px solid white;
      border-top: 12px solid transparent;
      border-bottom: 12px solid transparent;
      margin-left: 5px;
    }
    /* Video modal styling */
    #videoModal {
      border: none;
      background: transparent;
      max-width: 100vw;
      max-height: 100vh;
      padding: 0;
    }
    #videoModal::backdrop {
      background: rgba(0, 0, 0, 0.9);
    }
    #videoModal .video-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #videoModal video {
      max-width: 95vw;
      max-height: 95vh;
      object-fit: contain;
    }
    #videoModal:focus {
      outline: none;
    }
    #videoModal .close-btn {
      position: absolute;
      top: -30px;
      right: 0;
      background: none;
      border: none;
      color: white;
      font-size: 24px;
      cursor: pointer;
      padding: 5px 10px;
    }
    .quote-tweet {
      border: 1px solid #d0d7de;
      border-left: 3px solid #1185fe;
      border-radius: 8px;
      padding: 0.75em;
      margin-top: 0.5em;
      background: linear-gradient(to right, #f0f7ff, #f9f9f9);
      position: relative;
    }
    .quote-tweet .qt-header {
      display: flex;
      align-items: center;
      gap: 0.4em;
      margin-bottom: 0.25em;
    }
    .quote-tweet .qt-icon {
      width: 16px;
      height: 16px;
      color: #1185fe;
      flex-shrink: 0;
    }
    .quote-tweet .qt-author {
      font-weight: bold;
      font-size: 0.9rem;
    }
    .quote-tweet .qt-meta {
      font-size: 0.8rem;
      margin-bottom: 0.25em;
      display: flex;
      gap: 0.5em;
    }
    .quote-tweet .qt-meta a {
      color: #007bff;
      text-decoration: none;
    }
    .quote-tweet .qt-meta a:hover {
      text-decoration: underline;
    }
    .quote-tweet .qt-text {
      font-size: 0.9rem;
      white-space: pre-wrap;
      line-height: 1.3;
    }
    .quote-tweet .images img {
      max-height: 100px;
    }
    .external-link {
      border: 1px solid #ccc;
      border-radius: 8px;
      margin-top: 0.5em;
      overflow: hidden;
      display: block;
      text-decoration: none;
      color: inherit;
    }
    .external-link:hover {
      background: #f5f5f5;
    }
    .external-link .el-thumb {
      width: 100%;
      max-height: 200px;
      object-fit: cover;
    }
    .external-link .el-content {
      padding: 0.5em 0.75em;
    }
    .external-link .el-title {
      font-weight: bold;
      font-size: 0.9rem;
      margin-bottom: 0.25em;
    }
    .external-link .el-desc {
      font-size: 0.8rem;
      color: #666;
    }
    .external-link .el-url {
      font-size: 0.75rem;
      color: #888;
      margin-top: 0.25em;
    }
    /* Hide other replies toggle */
    .hide-replies-toggle {
      display: block;
      margin-top: 0.75em;
      padding: 0.4em 0.8em;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #555;
      cursor: pointer;
    }
    .hide-replies-toggle:hover {
      background: #e5e5e5;
    }
    /* When hiding replies, only show depth-1 posts by the root author */
    #threadContainer.hide-other-replies .post:not(.depth-1.root-author-post) {
      display: none;
    }
    .post.clickable {
      cursor: pointer;
      transition: box-shadow 0.2s, transform 0.1s;
    }
    .post.clickable:hover {
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transform: translateY(-1px);
    }
    .post.clickable.selected {
      box-shadow: 0 0 0 2px #007bff;
    }
    @media (max-width: 1000px) {
      .main-layout {
        flex-direction: column;
      }
      .ai-panel {
        width: 100%;
        position: static;
        max-height: none;
      }
    }
    @media (max-width: 600px) {
      .post { padding-left: 1em; }
    }
  </style>
</head>
<body>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
  <dialog id="imageModal"><img src="" alt=""></dialog>
  <dialog id="videoModal">
    <div class="video-wrapper">
      <button class="close-btn">&times;</button>
      <video controls playsinline></video>
    </div>
  </dialog>
  <div class="main-layout">
    <div class="content-area">
      <header>
        <h1>Bluesky Thread Viewer</h1>
        <div class="controls">
          <form id="urlForm">
            <input type="text" id="postUrl" placeholder="Bluesky post URL" required />
            <button type="submit">Fetch Thread</button>
          </form>
        </div>
        <div class="copy-container">
          <button id="copyBtn">Copy</button>
          <button id="copyJsonBtn">Copy JSON</button>
        </div>
        <div class="tabs" id="viewTabs">
          <button class="tab active" data-view="thread">Thread View</button>
          <button class="tab" data-view="recent">Most Recent First</button>
        </div>
      </header>
      <div id="threadContainer"></div>
    </div>
    <div class="ai-panel visible" id="aiPanel">
      <h3>AI Explanation</h3>
      <div class="ai-controls">
        <select id="aiProvider">
          <option value="openai">OpenAI</option>
          <option value="anthropic">Anthropic</option>
          <option value="google">Google</option>
        </select>
        <input type="password" id="apiKey" placeholder="Enter API Key" />
      </div>
      <div class="ai-selected-post" id="selectedPostPreview" style="display: none;">
        <div class="selected-author"></div>
        <div class="selected-text"></div>
      </div>
      <div class="ai-response" id="aiResponse">
        Click on any post to get an AI explanation of what it means in the context of the thread.
      </div>
    </div>
  </div>

  <script>
    (async () => {
      const form = document.getElementById('urlForm');
      const container = document.getElementById('threadContainer');
      const copyBtn = document.getElementById('copyBtn');
      const copyJsonBtn = document.getElementById('copyJsonBtn');
      const copyContainer = document.querySelector('.copy-container');
      const viewTabs = document.getElementById('viewTabs');
      const postUrl = document.getElementById('postUrl');
      const aiPanel = document.getElementById('aiPanel');
      const aiProvider = document.getElementById('aiProvider');
      const apiKeyInput = document.getElementById('apiKey');
      const aiResponse = document.getElementById('aiResponse');
      const selectedPostPreview = document.getElementById('selectedPostPreview');
      let lastThread = null;
      let allPosts = []; // Flat array of all posts with metadata
      let currentView = 'thread';
      let hideOtherReplies = false;
      let selectedPostUri = null;

      // Load saved API keys from localStorage
      const savedKeys = JSON.parse(localStorage.getItem('aiApiKeys') || '{}');
      const savedProvider = localStorage.getItem('aiProvider');
      if (savedProvider) aiProvider.value = savedProvider;
      if (savedKeys[aiProvider.value]) apiKeyInput.value = savedKeys[aiProvider.value];

      aiProvider.addEventListener('change', () => {
        localStorage.setItem('aiProvider', aiProvider.value);
        apiKeyInput.value = savedKeys[aiProvider.value] || '';
      });

      apiKeyInput.addEventListener('change', () => {
        savedKeys[aiProvider.value] = apiKeyInput.value;
        localStorage.setItem('aiApiKeys', JSON.stringify(savedKeys));
      });

      // Extract images from a post's embed (including quoted posts)
      function getImagesFromPost(post) {
        const images = [];
        const embed = post.embed;
        if (!embed) return images;

        // Direct images
        if (embed.$type === 'app.bsky.embed.images#view' && embed.images) {
          embed.images.forEach(img => {
            images.push({ url: img.fullsize, alt: img.alt || '' });
          });
        }

        // Images in recordWithMedia
        if (embed.$type === 'app.bsky.embed.recordWithMedia#view' && embed.media) {
          if (embed.media.$type === 'app.bsky.embed.images#view' && embed.media.images) {
            embed.media.images.forEach(img => {
              images.push({ url: img.fullsize, alt: img.alt || '' });
            });
          }
        }

        // Images from quoted posts
        let quotedRecord = null;
        if (embed.$type === 'app.bsky.embed.record#view' && embed.record) {
          quotedRecord = embed.record;
        } else if (embed.$type === 'app.bsky.embed.recordWithMedia#view' && embed.record?.record) {
          quotedRecord = embed.record.record;
        }

        if (quotedRecord && quotedRecord.$type === 'app.bsky.embed.record#viewRecord' && quotedRecord.embeds) {
          quotedRecord.embeds.forEach(qtEmbed => {
            if (qtEmbed.$type === 'app.bsky.embed.images#view' && qtEmbed.images) {
              qtEmbed.images.forEach(img => {
                images.push({ url: img.fullsize, alt: img.alt || '', fromQuote: true });
              });
            }
          });
        }

        return images;
      }

      // Extract external links from a post's embed
      function getExternalLinksFromPost(post) {
        const links = [];
        const embed = post.embed;
        if (!embed) return links;

        // Direct external link
        if (embed.$type === 'app.bsky.embed.external#view' && embed.external) {
          links.push({
            url: embed.external.uri,
            title: embed.external.title || '',
            description: embed.external.description || ''
          });
        }

        // External link in recordWithMedia (less common but possible)
        if (embed.$type === 'app.bsky.embed.recordWithMedia#view' && embed.media) {
          if (embed.media.$type === 'app.bsky.embed.external#view' && embed.media.external) {
            links.push({
              url: embed.media.external.uri,
              title: embed.media.external.title || '',
              description: embed.media.external.description || ''
            });
          }
        }

        return links;
      }

      // Collect all external links from the thread
      function collectThreadLinks(item) {
        const links = [];
        const postLinks = getExternalLinksFromPost(item.post);
        postLinks.forEach(link => {
          const author = item.post.author.displayName || item.post.author.handle;
          links.push({ ...link, author });
        });

        if (item.replies && item.replies.length) {
          item.replies.forEach(reply => {
            links.push(...collectThreadLinks(reply));
          });
        }
        return links;
      }

      // Fetch page content with CORS proxy fallback
      async function fetchPageContent(url) {
        const corsProxies = [
          (u) => u, // Try direct first
          (u) => `https://api.allorigins.win/raw?url=${encodeURIComponent(u)}`,
          (u) => `https://corsproxy.io/?${encodeURIComponent(u)}`
        ];

        for (const proxyFn of corsProxies) {
          try {
            const proxyUrl = proxyFn(url);
            const response = await fetch(proxyUrl, {
              signal: AbortSignal.timeout(5000) // 5 second timeout
            });
            if (!response.ok) continue;

            const html = await response.text();
            // Extract text content from HTML
            const doc = new DOMParser().parseFromString(html, 'text/html');

            // Remove script and style elements
            doc.querySelectorAll('script, style, nav, header, footer, aside').forEach(el => el.remove());

            // Try to get main content
            const main = doc.querySelector('main, article, [role="main"], .content, .post, .article');
            const textSource = main || doc.body;

            // Get text and clean it up
            let text = textSource?.textContent || '';
            text = text.replace(/\s+/g, ' ').trim();

            // Limit to first 2000 chars to avoid overwhelming the AI
            if (text.length > 2000) {
              text = text.slice(0, 2000) + '...';
            }

            if (text.length > 100) { // Only return if we got meaningful content
              return text;
            }
          } catch (e) {
            // Try next proxy
            continue;
          }
        }
        return null; // All methods failed
      }

      // Fetch content for all links in parallel
      async function fetchAllLinkContents(links) {
        const results = await Promise.all(
          links.map(async (link) => {
            const content = await fetchPageContent(link.url);
            return { ...link, content };
          })
        );
        return results;
      }

      // Collect all images from the thread
      function collectThreadImages(item) {
        const images = [];
        const postImages = getImagesFromPost(item.post);
        postImages.forEach(img => {
          const author = item.post.author.displayName || item.post.author.handle;
          images.push({ ...img, author });
        });

        if (item.replies && item.replies.length) {
          item.replies.forEach(reply => {
            images.push(...collectThreadImages(reply));
          });
        }
        return images;
      }

      // AI API call functions
      async function callOpenAI(apiKey, systemPrompt, userPrompt, images = []) {
        // Build content array with text and images
        const userContent = [{ type: 'text', text: userPrompt }];
        images.forEach(img => {
          userContent.push({
            type: 'image_url',
            image_url: { url: img.url, detail: 'low' }
          });
        });

        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: userContent }
            ],
            max_tokens: 1000
          })
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.error?.message || `OpenAI API error: ${response.status}`);
        }
        const data = await response.json();
        return data.choices[0].message.content;
      }

      async function callAnthropic(apiKey, systemPrompt, userPrompt, images = []) {
        // Build content array with text and images
        const userContent = [{ type: 'text', text: userPrompt }];
        images.forEach(img => {
          userContent.push({
            type: 'image',
            source: { type: 'url', url: img.url }
          });
        });

        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-api-key': apiKey,
            'anthropic-version': '2023-06-01',
            'anthropic-dangerous-direct-browser-access': 'true'
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 1000,
            system: systemPrompt,
            messages: [
              { role: 'user', content: userContent }
            ]
          })
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.error?.message || `Anthropic API error: ${response.status}`);
        }
        const data = await response.json();
        return data.content[0].text;
      }

      async function callGoogle(apiKey, systemPrompt, userPrompt, images = []) {
        // Build parts array with text and images
        const parts = [{ text: userPrompt }];
        images.forEach(img => {
          parts.push({
            file_data: { file_uri: img.url, mime_type: 'image/jpeg' }
          });
        });

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            system_instruction: { parts: [{ text: systemPrompt }] },
            contents: [{ parts }]
          })
        });
        if (!response.ok) {
          const err = await response.json();
          throw new Error(err.error?.message || `Google API error: ${response.status}`);
        }
        const data = await response.json();
        return data.candidates[0].content.parts[0].text;
      }

      async function explainPost(postUri, postAuthor, postText) {
        const apiKey = apiKeyInput.value.trim();
        if (!apiKey) {
          aiResponse.textContent = 'Please enter an API key first.';
          aiResponse.className = 'ai-response error';
          return;
        }

        // Show the panel
        aiPanel.classList.add('visible');

        // Show selected post preview
        selectedPostPreview.style.display = 'block';
        selectedPostPreview.querySelector('.selected-author').textContent = postAuthor;
        selectedPostPreview.querySelector('.selected-text').textContent =
          postText.length > 200 ? postText.slice(0, 200) + '...' : postText;

        // Show loading state
        aiResponse.textContent = 'Fetching linked pages...';
        aiResponse.className = 'ai-response loading';

        // Generate thread context and collect images and links
        const threadContext = generateThreadText(lastThread);
        const threadImages = collectThreadImages(lastThread);
        const threadLinks = collectThreadLinks(lastThread);

        // Fetch content from external links
        let linkContents = [];
        if (threadLinks.length > 0) {
          aiResponse.textContent = `Fetching ${threadLinks.length} linked page(s)...`;
          linkContents = await fetchAllLinkContents(threadLinks);
        }

        aiResponse.textContent = 'Thinking...';

        const systemPrompt = `You are a helpful assistant that explains social media posts in simple terms. You help people understand discussions even if they're not familiar with the topic. When images are included in the thread, describe and reference them in your explanation. When linked articles are included, use their content to provide better context.`;

        let userPrompt = `Here is a Bluesky thread conversation:

${threadContext}

The user clicked on this specific post:
Author: ${postAuthor}
Post: ${postText}

Please explain what this means so it's understandable to someone who is not well informed on this topic. Consider the context of the full thread when explaining.`;

        if (threadImages.length > 0) {
          userPrompt += `\n\nThe thread includes ${threadImages.length} image(s) which are attached below. Please consider them in your explanation.`;
        }

        // Add fetched link content
        const linksWithContent = linkContents.filter(l => l.content);
        if (linksWithContent.length > 0) {
          userPrompt += `\n\n--- LINKED ARTICLE CONTENT ---\n`;
          linksWithContent.forEach((link, i) => {
            userPrompt += `\n[Article ${i + 1}: "${link.title}" - ${link.url}]\n${link.content}\n`;
          });
        }

        try {
          let result;
          const provider = aiProvider.value;

          if (provider === 'openai') {
            result = await callOpenAI(apiKey, systemPrompt, userPrompt, threadImages);
          } else if (provider === 'anthropic') {
            result = await callAnthropic(apiKey, systemPrompt, userPrompt, threadImages);
          } else if (provider === 'google') {
            result = await callGoogle(apiKey, systemPrompt, userPrompt, threadImages);
          }

          aiResponse.textContent = result;
          aiResponse.className = 'ai-response';
        } catch (err) {
          console.error('AI API error:', err);
          aiResponse.textContent = 'Error: ' + err.message;
          aiResponse.className = 'ai-response error';
        }
      }

      // Handle post click
      function handlePostClick(e, item) {
        // Don't trigger if clicking on a link, button, or image
        if (e.target.closest('a, button, img, .video-container')) return;

        e.stopPropagation();

        // Remove previous selection
        document.querySelectorAll('.post.selected').forEach(p => p.classList.remove('selected'));

        // Select this post
        const postEl = e.currentTarget;
        postEl.classList.add('selected');
        selectedPostUri = item.post.uri;

        const author = `${item.post.author.displayName || item.post.author.handle} (@${item.post.author.handle})`;
        const text = item.post.record.text;

        explainPost(item.post.uri, author, text);
      }

      postUrl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); form.requestSubmit(); }
      });

      // Extract post ID from URI for use as element ID
      function getPostId(uri) {
        return 'post-' + uri.split('/').pop();
      }

      // Flatten thread into array of posts with parent info
      function flattenThread(item, parentUri = null, parentAuthor = null) {
        const posts = [];
        posts.push({
          item,
          parentUri,
          parentAuthor,
          uri: item.post.uri,
          createdAt: new Date(item.post.record.createdAt)
        });
        if (item.replies && item.replies.length) {
          const authorName = item.post.author.displayName || item.post.author.handle;
          item.replies.forEach(reply => {
            posts.push(...flattenThread(reply, item.post.uri, authorName));
          });
        }
        return posts;
      }

      // Render text with facets (links, mentions, etc.)
      function renderTextWithFacets(text, facets) {
        if (!facets || !facets.length) {
          return document.createTextNode(text);
        }

        // Convert string to bytes for accurate indexing
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const bytes = encoder.encode(text);

        // Sort facets by start index
        const sorted = [...facets].sort((a, b) => a.index.byteStart - b.index.byteStart);

        const container = document.createDocumentFragment();
        let lastEnd = 0;

        for (const facet of sorted) {
          const { byteStart, byteEnd } = facet.index;

          // Add text before this facet
          if (byteStart > lastEnd) {
            const before = decoder.decode(bytes.slice(lastEnd, byteStart));
            container.appendChild(document.createTextNode(before));
          }

          // Get the facet text
          const facetText = decoder.decode(bytes.slice(byteStart, byteEnd));

          // Check for link feature
          const linkFeature = facet.features.find(f => f.$type === 'app.bsky.richtext.facet#link');
          if (linkFeature) {
            const link = document.createElement('a');
            link.href = linkFeature.uri;
            link.target = '_blank';
            link.textContent = facetText;
            container.appendChild(link);
          } else {
            // For other facet types (mentions, tags), just render as text for now
            container.appendChild(document.createTextNode(facetText));
          }

          lastEnd = byteEnd;
        }

        // Add remaining text after last facet
        if (lastEnd < bytes.length) {
          const after = decoder.decode(bytes.slice(lastEnd));
          container.appendChild(document.createTextNode(after));
        }

        return container;
      }

      // Image modal setup
      const imageModal = document.getElementById('imageModal');
      const modalImg = imageModal.querySelector('img');
      imageModal.addEventListener('click', () => imageModal.close());

      function openImageModal(src, alt) {
        modalImg.src = src;
        modalImg.alt = alt || '';
        imageModal.showModal();
      }

      // Video modal setup
      const videoModal = document.getElementById('videoModal');
      const modalVideo = videoModal.querySelector('video');
      const videoCloseBtn = videoModal.querySelector('.close-btn');
      let hlsInstance = null;

      function closeVideoModal() {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        modalVideo.pause();
        modalVideo.src = '';
        videoModal.close();
      }

      videoCloseBtn.addEventListener('click', closeVideoModal);
      videoModal.addEventListener('click', (e) => {
        // Close when clicking backdrop (outside video wrapper)
        if (e.target === videoModal) {
          closeVideoModal();
        }
      });

      function openVideoModal(playlistUrl) {
        if (Hls.isSupported()) {
          hlsInstance = new Hls();
          hlsInstance.loadSource(playlistUrl);
          hlsInstance.attachMedia(modalVideo);
          hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
            modalVideo.play();
          });
        } else if (modalVideo.canPlayType('application/vnd.apple.mpegurl')) {
          // Native HLS support (Safari)
          modalVideo.src = playlistUrl;
          modalVideo.addEventListener('loadedmetadata', () => {
            modalVideo.play();
          }, { once: true });
        }
        videoModal.showModal();
      }

      // Render video thumbnail with play button
      function renderVideo(videoEmbed) {
        if (!videoEmbed) return null;
        const container = document.createElement('div');
        container.className = 'video-container';

        if (videoEmbed.thumbnail) {
          const thumb = document.createElement('img');
          thumb.src = videoEmbed.thumbnail;
          thumb.alt = videoEmbed.alt || 'Video thumbnail';
          thumb.title = videoEmbed.alt || 'Click to play video';
          container.appendChild(thumb);
        }

        // Play icon overlay
        const playIcon = document.createElement('div');
        playIcon.className = 'video-play-icon';
        container.appendChild(playIcon);

        container.addEventListener('click', () => {
          openVideoModal(videoEmbed.playlist);
        });

        return container;
      }

      // Render images from an embed
      function renderImages(images) {
        if (!images || !images.length) return null;
        const container = document.createElement('div');
        container.className = 'images';
        images.forEach(img => {
          const imgEl = document.createElement('img');
          imgEl.src = img.thumb;
          imgEl.alt = img.alt || '';
          imgEl.title = img.alt || '';
          imgEl.addEventListener('click', () => openImageModal(img.fullsize, img.alt));
          container.appendChild(imgEl);
        });
        return container;
      }

      // Render external link preview
      function renderExternalLink(external) {
        if (!external) return null;
        const link = document.createElement('a');
        link.className = 'external-link';
        link.href = external.uri;
        link.target = '_blank';
        if (external.thumb) {
          const thumb = document.createElement('img');
          thumb.className = 'el-thumb';
          thumb.src = external.thumb;
          link.appendChild(thumb);
        }
        const content = document.createElement('div');
        content.className = 'el-content';
        if (external.title) {
          const title = document.createElement('div');
          title.className = 'el-title';
          title.textContent = external.title;
          content.appendChild(title);
        }
        if (external.description) {
          const desc = document.createElement('div');
          desc.className = 'el-desc';
          desc.textContent = external.description;
          content.appendChild(desc);
        }
        const url = document.createElement('div');
        url.className = 'el-url';
        url.textContent = new URL(external.uri).hostname;
        content.appendChild(url);
        link.appendChild(content);
        return link;
      }

      // Render a quoted post
      function renderQuoteTweet(record) {
        if (!record || record.$type !== 'app.bsky.embed.record#viewRecord') return null;
        const qt = document.createElement('div');
        qt.className = 'quote-tweet';

        // Header with quote icon and author
        const header = document.createElement('div');
        header.className = 'qt-header';

        // Quote icon SVG
        const icon = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        icon.setAttribute('class', 'qt-icon');
        icon.setAttribute('viewBox', '0 0 24 24');
        icon.setAttribute('fill', 'currentColor');
        icon.innerHTML = '<path d="M4.583 17.321C3.553 16.227 3 15 3 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 01-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179zm10 0C13.553 16.227 13 15 13 13.011c0-3.5 2.457-6.637 6.03-8.188l.893 1.378c-3.335 1.804-3.987 4.145-4.247 5.621.537-.278 1.24-.375 1.929-.311 1.804.167 3.226 1.648 3.226 3.489a3.5 3.5 0 01-3.5 3.5c-1.073 0-2.099-.49-2.748-1.179z"/>';
        header.appendChild(icon);

        const author = document.createElement('div');
        author.className = 'qt-author';
        author.textContent = `${record.author.displayName || record.author.handle} (@${record.author.handle})`;
        header.appendChild(author);
        qt.appendChild(header);

        // Add meta with View links
        const postId = record.uri.split('/').pop();
        const bskyUrl = `https://bsky.app/profile/${record.author.handle}/post/${postId}`;
        const viewerUrl = `?url=${encodeURIComponent(bskyUrl)}&view=thread`;

        const meta = document.createElement('div');
        meta.className = 'qt-meta';
        const viewLink = document.createElement('a');
        viewLink.href = viewerUrl;
        viewLink.textContent = 'View';
        const bskyLink = document.createElement('a');
        bskyLink.href = bskyUrl;
        bskyLink.target = '_blank';
        bskyLink.textContent = 'View in Bluesky';
        meta.appendChild(viewLink);
        meta.appendChild(bskyLink);
        qt.appendChild(meta);

        if (record.value && record.value.text) {
          const text = document.createElement('div');
          text.className = 'qt-text';
          text.textContent = record.value.text;
          qt.appendChild(text);
        }

        // Handle embeds within the quoted post
        if (record.embeds && record.embeds.length) {
          record.embeds.forEach(embed => {
            const embedEl = renderEmbed(embed);
            if (embedEl) qt.appendChild(embedEl);
          });
        }

        return qt;
      }

      // Render any embed type
      function renderEmbed(embed) {
        if (!embed) return null;
        const type = embed.$type;

        if (type === 'app.bsky.embed.images#view') {
          return renderImages(embed.images);
        }

        if (type === 'app.bsky.embed.video#view') {
          return renderVideo(embed);
        }

        if (type === 'app.bsky.embed.external#view') {
          return renderExternalLink(embed.external);
        }

        if (type === 'app.bsky.embed.record#view') {
          return renderQuoteTweet(embed.record);
        }

        if (type === 'app.bsky.embed.recordWithMedia#view') {
          const container = document.createElement('div');
          // Render the media (images or video)
          if (embed.media) {
            if (embed.media.$type === 'app.bsky.embed.images#view') {
              const images = renderImages(embed.media.images);
              if (images) container.appendChild(images);
            } else if (embed.media.$type === 'app.bsky.embed.video#view') {
              const video = renderVideo(embed.media);
              if (video) container.appendChild(video);
            }
          }
          // Render the quoted record
          if (embed.record && embed.record.record) {
            const qt = renderQuoteTweet(embed.record.record);
            if (qt) container.appendChild(qt);
          }
          return container;
        }

        return null;
      }

      // Fixed function to generate thread text in a readable format
      // Extract quoted post text from an embed
      function getQuotedPostText(embed) {
        if (!embed) return null;

        let record = null;
        if (embed.$type === 'app.bsky.embed.record#view' && embed.record) {
          record = embed.record;
        } else if (embed.$type === 'app.bsky.embed.recordWithMedia#view' && embed.record?.record) {
          record = embed.record.record;
        }

        if (record && record.$type === 'app.bsky.embed.record#viewRecord' && record.value?.text) {
          const qtAuthor = record.author?.displayName || record.author?.handle || 'Unknown';
          const qtText = record.value.text.replace(/\n/g, ' ');
          return `[Quoting @${qtAuthor}: ${qtText}]`;
        }
        return null;
      }

      // Get external link metadata text
      function getExternalLinkText(embed) {
        if (!embed) return null;

        let external = null;
        if (embed.$type === 'app.bsky.embed.external#view' && embed.external) {
          external = embed.external;
        } else if (embed.$type === 'app.bsky.embed.recordWithMedia#view' && embed.media?.$type === 'app.bsky.embed.external#view') {
          external = embed.media.external;
        }

        if (external) {
          let linkText = `[Link: "${external.title || 'Untitled'}"`;
          if (external.description) {
            const desc = external.description.length > 150
              ? external.description.slice(0, 150) + '...'
              : external.description;
            linkText += ` - ${desc}`;
          }
          linkText += ` (${external.uri})]`;
          return linkText;
        }
        return null;
      }

      function generateThreadText(thread) {
        const lines = [];

        function processPost(item, prefix = '1') {
          const author = item.post.author.displayName || item.post.author.handle;
          const text = item.post.record.text.replace(/\n/g, ' ');
          let postLine = `[${prefix}] ${author}: ${text}`;

          // Include quoted post if present
          const quotedText = getQuotedPostText(item.post.embed);
          if (quotedText) {
            postLine += `\n    ${quotedText}`;
          }

          // Include external link if present
          const linkText = getExternalLinkText(item.post.embed);
          if (linkText) {
            postLine += `\n    ${linkText}`;
          }

          lines.push(postLine);

          if (item.replies && item.replies.length > 0) {
            item.replies.forEach((reply, i) => {
              processPost(reply, `${prefix}.${i+1}`);
            });
          }
        }

        processPost(thread);
        return lines.join('\n\n');
      }

      // Display post in thread view (nested)
      // rootAuthorDid: the DID of the root post author (for flattening self-replies)
      // rootContainer: the top-level container element (for appending flattened self-replies)
      // parentAuthorDid: the DID of the parent post's author (to detect self-replies)
      // parentAtRootLevel: whether the parent post is at the root level (depth 1)
      function displayPostThread(item, parent, depth = 1, rootAuthorDid = null, rootContainer = null, parentAuthorDid = null, parentAtRootLevel = true) {
        const currentAuthorDid = item.post.author.did;
        // Initialize rootAuthorDid and rootContainer on first call (root post)
        const isRootPost = rootAuthorDid === null;
        if (isRootPost) {
          rootAuthorDid = currentAuthorDid;
          rootContainer = parent;
        }

        // Flatten only when root author replies to their own root-level post
        const isRootAuthorPost = currentAuthorDid === rootAuthorDid;
        const isSelfReplyAtRoot = isRootAuthorPost && parentAuthorDid === rootAuthorDid && parentAtRootLevel && !isRootPost;
        const shouldFlatten = isSelfReplyAtRoot;
        const effectiveParent = shouldFlatten ? rootContainer : parent;
        const effectiveDepth = shouldFlatten ? 1 : depth;
        const thisPostAtRootLevel = effectiveDepth === 1;

        const el = document.createElement('div');
        const classes = [`post`, `depth-${Math.min(effectiveDepth, 8)}`, 'clickable'];
        if (shouldFlatten) classes.push('author-continuation');
        if (isRootAuthorPost) classes.push('root-author-post');
        el.className = classes.join(' ');
        el.id = getPostId(item.post.uri);
        el.addEventListener('click', (e) => handlePostClick(e, item));
        const authorEl = document.createElement('div');
        authorEl.className = 'author';
        authorEl.textContent = `${item.post.author.displayName} (@${item.post.author.handle})`;
        const metaEl = document.createElement('div');
        metaEl.className = 'meta';
        metaEl.textContent = new Date(item.post.record.createdAt).toLocaleString();
        const link = document.createElement('a');
        link.href = `https://bsky.app/profile/${item.post.author.handle}/post/${item.post.uri.split('/').pop()}`;
        link.textContent = 'View in Bluesky';
        link.target = '_blank';
        metaEl.appendChild(link);
        const textEl = document.createElement('div');
        textEl.className = 'text';
        textEl.appendChild(renderTextWithFacets(item.post.record.text, item.post.record.facets));
        el.append(authorEl, metaEl, textEl);
        // Render embed if present
        if (item.post.embed) {
          const embedEl = renderEmbed(item.post.embed);
          if (embedEl) el.appendChild(embedEl);
        }
        effectiveParent.appendChild(el);
        if (item.replies && item.replies.length) {
          item.replies.forEach(reply => {
            // If this post was flattened to root, replies to it should be at depth 2
            const nextDepth = shouldFlatten ? 2 : depth + 1;
            displayPostThread(reply, el, nextDepth, rootAuthorDid, rootContainer, currentAuthorDid, thisPostAtRootLevel);
          });
        }
      }

      // Display posts in chronological order (most recent first)
      function displayPostsChronological() {
        container.innerHTML = '';
        const sorted = [...allPosts].sort((a, b) => b.createdAt - a.createdAt);

        sorted.forEach(postData => {
          const item = postData.item;
          const el = document.createElement('div');
          el.className = 'post depth-1 clickable';
          el.id = getPostId(item.post.uri);
          el.addEventListener('click', (e) => handlePostClick(e, item));

          // Add "in reply to" if this is a reply
          if (postData.parentUri) {
            const replyToEl = document.createElement('div');
            replyToEl.className = 'reply-to';
            const replyLink = document.createElement('a');
            replyLink.href = '#' + getPostId(postData.parentUri);
            replyLink.textContent = `in reply to ${postData.parentAuthor}`;
            replyLink.addEventListener('click', (e) => {
              e.preventDefault();
              const targetEl = document.getElementById(getPostId(postData.parentUri));
              if (targetEl) {
                targetEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                targetEl.classList.add('highlighted');
                setTimeout(() => targetEl.classList.remove('highlighted'), 2000);
              }
            });
            replyToEl.appendChild(replyLink);
            el.appendChild(replyToEl);
          }

          const authorEl = document.createElement('div');
          authorEl.className = 'author';
          authorEl.textContent = `${item.post.author.displayName} (@${item.post.author.handle})`;
          const metaEl = document.createElement('div');
          metaEl.className = 'meta';
          metaEl.textContent = new Date(item.post.record.createdAt).toLocaleString();
          const link = document.createElement('a');
          link.href = `https://bsky.app/profile/${item.post.author.handle}/post/${item.post.uri.split('/').pop()}`;
          link.textContent = 'View in Bluesky';
          link.target = '_blank';
          metaEl.appendChild(link);
          const textEl = document.createElement('div');
          textEl.className = 'text';
          textEl.appendChild(renderTextWithFacets(item.post.record.text, item.post.record.facets));
          el.append(authorEl, metaEl, textEl);
          // Render embed if present
          if (item.post.embed) {
            const embedEl = renderEmbed(item.post.embed);
            if (embedEl) el.appendChild(embedEl);
          }
          container.appendChild(el);
        });
      }

      // Display thread view
      function displayThreadView() {
        container.innerHTML = '';
        if (lastThread) {
          displayPostThread(lastThread, container);
        }
      }

      // Render current view
      function renderCurrentView() {
        if (currentView === 'thread') {
          displayThreadView();
        } else {
          displayPostsChronological();
        }
        setupHideRepliesToggle();
      }

      // Setup the "Hide other replies" toggle if conditions are met
      function setupHideRepliesToggle() {
        // Remove any existing toggle
        const existingToggle = container.querySelector('.hide-replies-toggle');
        if (existingToggle) existingToggle.remove();

        // Only show in thread view
        if (currentView !== 'thread') {
          container.classList.remove('hide-other-replies');
          return;
        }

        const rootAuthorPosts = container.querySelectorAll('.post.root-author-post');
        const otherPosts = container.querySelectorAll('.post:not(.root-author-post)');

        // Only show toggle if there are multiple root author posts AND other replies exist
        if (rootAuthorPosts.length < 2 || otherPosts.length === 0) {
          container.classList.remove('hide-other-replies');
          return;
        }

        // Apply current hide state
        if (hideOtherReplies) {
          container.classList.add('hide-other-replies');
        } else {
          container.classList.remove('hide-other-replies');
        }

        // Create toggle button
        const toggle = document.createElement('button');
        toggle.className = 'hide-replies-toggle';
        updateToggleText(toggle, otherPosts.length);

        toggle.addEventListener('click', () => {
          hideOtherReplies = !hideOtherReplies;
          container.classList.toggle('hide-other-replies', hideOtherReplies);
          updateToggleText(toggle, otherPosts.length);

          // Update URL
          const newUrl = new URL(window.location);
          if (hideOtherReplies) {
            newUrl.searchParams.set('hideReplies', '1');
          } else {
            newUrl.searchParams.delete('hideReplies');
          }
          history.replaceState(null, '', newUrl);
        });

        // Insert toggle in the first root post, before any nested replies
        const firstRootPost = rootAuthorPosts[0];
        const firstNestedReply = firstRootPost.querySelector('.post');
        if (firstNestedReply) {
          firstRootPost.insertBefore(toggle, firstNestedReply);
        } else {
          firstRootPost.appendChild(toggle);
        }
      }

      function updateToggleText(toggle, otherCount) {
        if (hideOtherReplies) {
          toggle.textContent = `Show ${otherCount} other repl${otherCount === 1 ? 'y' : 'ies'}`;
        } else {
          toggle.textContent = 'Hide other replies';
        }
      }

      // Tab click handlers
      viewTabs.addEventListener('click', (e) => {
        if (e.target.classList.contains('tab')) {
          const view = e.target.dataset.view;
          if (view !== currentView) {
            currentView = view;
            viewTabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            e.target.classList.add('active');
            // Update URL with current view
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('view', view);
            history.replaceState(null, '', newUrl);
            renderCurrentView();
          }
        }
      });

      copyBtn.addEventListener('click', async () => {
        if (!lastThread) return;
        try {
          const textToCopy = generateThreadText(lastThread);
          await navigator.clipboard.writeText(textToCopy);
          const orig = copyBtn.textContent;
          copyBtn.textContent = 'Copied!';
          setTimeout(() => (copyBtn.textContent = orig), 2000);
        } catch (err) {
          console.error('Copy failed', err);
        }
      });

      copyJsonBtn.addEventListener('click', async () => {
        if (!lastThread) return;
        const jsonToCopy = JSON.stringify(lastThread, null, 2);
        try {
          await navigator.clipboard.writeText(jsonToCopy);
          const orig = copyJsonBtn.textContent;
          copyJsonBtn.textContent = 'Copied!';
          setTimeout(() => (copyJsonBtn.textContent = orig), 2000);
        } catch (err) {
          console.error('Copy JSON failed', err);
        }
      });

      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        container.innerHTML = '';
        copyContainer.style.display = 'none';
        viewTabs.style.display = 'none';
        selectedPostPreview.style.display = 'none';
        aiResponse.textContent = 'Click on any post to get an AI explanation of what it means in the context of the thread.';
        aiResponse.className = 'ai-response';
        selectedPostUri = null;
        lastThread = null;
        allPosts = [];
        // Reset hide state for new thread (will be restored from URL if present)
        const currentParams = new URLSearchParams(window.location.search);
        if (!currentParams.get('hideReplies')) {
          hideOtherReplies = false;
        }
        // Update URL with the submitted post URL and current view
        const newUrl = new URL(window.location);
        newUrl.searchParams.set('url', postUrl.value.trim());
        newUrl.searchParams.set('view', currentView);
        history.replaceState(null, '', newUrl);
        try {
          const url = new URL(postUrl.value.trim());
          if (url.hostname !== 'bsky.app') throw new Error('URL must be from bsky.app');
          const parts = url.pathname.split('/').filter(Boolean);
          if (parts[0] !== 'profile' || parts[2] !== 'post') throw new Error('Use https://bsky.app/profile/{handle}/post/{postId}');
          const rawHandle = parts[1];
          const actor = rawHandle.includes('.') ? rawHandle : `${rawHandle}.bsky.social`;
          const postId = parts[3];

          const profileRes = await fetch(
            `https://public.api.bsky.app/xrpc/app.bsky.actor.getProfile?actor=${encodeURIComponent(actor)}`
          );
          if (!profileRes.ok) throw new Error('Profile fetch failed ' + profileRes.status);
          const profileJson = await profileRes.json();
          const did = profileJson.did || profileJson.profile?.did;
          if (!did) throw new Error('Could not parse DID');

          const atUri = `at://${did}/app.bsky.feed.post/${postId}`;
          const threadRes = await fetch(
            `https://public.api.bsky.app/xrpc/app.bsky.feed.getPostThread?uri=${encodeURIComponent(atUri)}&depth=1000&parentHeight=0`
          );
          if (!threadRes.ok) throw new Error('Thread fetch failed ' + threadRes.status);
          const threadJson = await threadRes.json();
          if (threadJson.thread.$type === 'app.bsky.feed.defs#notFoundPost') throw new Error('Post not found');

          lastThread = threadJson.thread;
          allPosts = flattenThread(threadJson.thread);
          renderCurrentView();
          copyContainer.style.display = 'block';
          viewTabs.style.display = 'block';

          // Set document title and page heading
          const rootAuthor = lastThread.post.author.handle;
          const rootText = lastThread.post.record.text.replace(/\n/g, ' ');
          const truncatedText = rootText.length > 80 ? rootText.slice(0, 80) + '' : rootText;
          document.title = `Thread by @${rootAuthor}: ${truncatedText}`;
          document.querySelector('h1').textContent = `Thread by @${rootAuthor}`;
        } catch (err) {
          console.error(err);
          container.textContent = 'Error: ' + err.message;
        }
      });

      // Check for query parameters on page load
      const params = new URLSearchParams(window.location.search);
      const urlParam = params.get('url');
      const viewParam = params.get('view');
      const hideRepliesParam = params.get('hideReplies');
      // Initialize view from URL parameter if valid
      if (viewParam === 'thread' || viewParam === 'recent') {
        currentView = viewParam;
        viewTabs.querySelectorAll('.tab').forEach(t => {
          t.classList.toggle('active', t.dataset.view === viewParam);
        });
      }
      // Initialize hide replies state from URL
      if (hideRepliesParam === '1') {
        hideOtherReplies = true;
      }
      if (urlParam) {
        postUrl.value = urlParam;
        form.requestSubmit();
      }
    })();
  </script>
</body>
</html>
